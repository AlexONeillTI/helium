{"version":3,"file":"use-multi-carousel-behavior-597a659b.js","sources":["../../node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js","../../node_modules/@use-gesture/core/dist/actions-8e12537b.esm.js","../../node_modules/@use-gesture/core/dist/use-gesture-core.esm.js","../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js","../../packages/hooks/src/use-carousel-behavior.ts","../../packages/hooks/src/use-multi-carousel-behavior.ts"],"sourcesContent":["function clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n\n};\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\nexport { V, computeRubberband as c, rubberbandIfOutOfBounds as r };\n","import { V, c as computeRubberband } from './maths-b2a210f4.esm.js';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\n\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\n\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (capture ? 'Capture' : '');\n}\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event)) return 'touch';\n  if ('pointerType' in event) return event.pointerType;\n  return 'mouse';\n}\n\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\n\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\n\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\n\nfunction distanceAngle(P1, P2) {\n  const dx = P2.clientX - P1.clientX;\n  const dy = P2.clientY - P1.clientY;\n  const cx = (P2.clientX + P1.clientX) / 2;\n  const cy = (P2.clientY + P1.clientY) / 2;\n  const distance = Math.hypot(dx, dy);\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  const origin = [cx, cy];\n  return {\n    angle,\n    distance,\n    origin\n  };\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nconst BEFORE_LAST_KINEMATICS_DELAY = 32;\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n    }\n\n    state.startTime = state.timeStamp = event.timeStamp;\n  }\n\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable) state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n\n      V.addTo(state._distance, _absoluteDelta);\n    }\n\n    if (this.axisIntent) this.axisIntent(event);\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n\n    if (config.hasCustomTransform) {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional) return;\n    const movement = [0, 0];\n\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n\n    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = computeRubberband(state._bounds, state.offset, rubberband);\n    state.delta = V.sub(state.offset, previousOffset);\n    this.computeMovement();\n\n    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n\n      if (!state.first && dt > 0) {\n        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n      }\n    }\n  }\n\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n\n}\n\nfunction selectAxis([dx, dy], threshold) {\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n\n  if (absDx > absDy && absDx > threshold) {\n    return 'x';\n  }\n\n  if (absDy > absDx && absDy > threshold) {\n    return 'y';\n  }\n\n  return undefined;\n}\n\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n\n  computeOffset() {\n    this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n  }\n\n  computeMovement() {\n    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n  }\n\n  axisIntent(event) {\n    const state = this.state;\n    const config = this.config;\n\n    if (!state.axis && event) {\n      const threshold = typeof config.axisThreshold === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n      state.axis = selectAxis(state._movement, threshold);\n    }\n\n    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n  }\n\n  restrictToAxis(v) {\n    if (this.config.axis || this.config.lockDirection) {\n      switch (this.state.axis) {\n        case 'x':\n          v[1] = 0;\n          break;\n\n        case 'y':\n          v[0] = 0;\n          break;\n      }\n    }\n  }\n\n}\n\nconst identity = v => v;\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n\n  preventDefault(value = false) {\n    return value;\n  },\n\n  triggerAllEvents(value = false) {\n    return value;\n  },\n\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n\n      case false:\n        return [0, 0];\n\n      default:\n        return V.toVector(value);\n    }\n  },\n\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return V.toVector(value);\n  },\n\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n\n    if (process.env.NODE_ENV === 'development') {\n      const originalTransform = transform || identity;\n      return v => {\n        const r = originalTransform(v);\n\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);\n        }\n\n        return r;\n      };\n    }\n\n    return transform || identity;\n  },\n\n  threshold(value) {\n    return V.toVector(value, 0);\n  }\n\n};\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n\n      return NaN;\n    },\n\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n\n      return NaN;\n    },\n\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n\n      return NaN;\n    }\n\n  });\n}\n\nconst DEFAULT_AXIS_THRESHOLD = 0;\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n\n  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {\n    return value;\n  },\n\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n\n    if ('current' in value) {\n      return () => value.current;\n    }\n\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n\n});\n\nconst DISPLACEMENT = 10;\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],\n  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],\n  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],\n  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n\n  setup() {\n    const state = this.state;\n\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n    this.ctrl.setEventIds(event);\n\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n\n    if (state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n\n    if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n\n      if (config.triggerAllEvents) {\n        this.compute(event);\n        this.emit();\n      }\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    if (state.type === event.type && event.timeStamp === state.timeStamp) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n\n    const _values = pointerValues(event);\n\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n\n    V.addTo(state._movement, state._delta);\n    this.compute(event);\n\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove('dragDelay');\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [dirx, diry] = state.direction;\n      const [vx, vy] = state.velocity;\n      const [mx, my] = state.movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n\n      if (state.elapsedTime < sdt) {\n        if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;\n        if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerClick(event) {\n    if (!this.state.tap) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n\n    if (process.env.NODE_ENV === 'development') {\n      try {\n        if (device === 'pointer' && config.preventScrollDelay === undefined) {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n    }\n  }\n\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n  setupScrollPrevention(event) {\n    persistEvent(event);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', this.clean.bind(this));\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', this.clean.bind(this));\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      state._delta = deltaFn(factor);\n      this.start(event);\n      state._keyboardActive = true;\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n    }\n\n    bindFunction('key', 'down', this.keyDown.bind(this));\n    bindFunction('key', 'up', this.keyUp.bind(this));\n\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n\n}\n\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\n\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\n\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\n\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\n\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\n\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = undefined\n  }) {\n    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration\n    };\n  },\n\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  },\n\n  axisThreshold(value) {\n    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  }\n\n});\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n\n      return NaN;\n    }\n\n  });\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 100;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'pinching');\n\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n\n    if (type === 'wheel') {\n      this.state.offset = V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n\n  axisIntent() {\n    const state = this.state;\n    const [_m0, _m1] = state._movement;\n\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n  }\n\n  restrictToAxis(v) {\n    if (this.config.lockDirection) {\n      if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    this.pinchStart(event, payload);\n  }\n\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchStart(event, payload);\n  }\n\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    this.pinchMove(event, payload);\n  }\n\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchMove(event, payload);\n  }\n\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n\n    if (!state._active) return;\n\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  wheel(event) {\n    const modifierKey = this.config.modifierKey;\n    if (modifierKey && !event[modifierKey]) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      if (process.env.NODE_ENV === 'development' && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    V.addTo(state._movement, state._delta);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n    } else {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n\n  modifierKey(value) {\n    if (value === undefined) return 'ctrlKey';\n    return value;\n  }\n\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    V.addTo(state._movement, state._delta);\n    const [ox, oy] = state.overflow;\n    const [dx, dy] = state._delta;\n    const [dirx, diry] = state._direction;\n\n    if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n      state._movement[0] = state._movementBound[0];\n    }\n\n    if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n      state._movement[1] = state._movementBound[1];\n    }\n\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\nexport { ConfigResolverMap as C, EngineMap as E, SUPPORT as S, _objectSpread2 as _, _defineProperty as a, touchIds as b, chain as c, toHandlerProp as d, dragAction as e, pinchAction as f, hoverAction as h, isTouch as i, moveAction as m, parseProp as p, registerAction as r, scrollAction as s, toDomEventType as t, wheelAction as w };\n","import { S as SUPPORT, C as ConfigResolverMap, _ as _objectSpread2, a as _defineProperty, t as toDomEventType, i as isTouch, b as touchIds, E as EngineMap, c as chain, p as parseProp, d as toHandlerProp } from './actions-8e12537b.esm.js';\nimport './maths-b2a210f4.esm.js';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n\n    return undefined;\n  },\n\n  enabled(value = true) {\n    return value;\n  },\n\n  window(value = SUPPORT.isBrowser ? window : undefined) {\n    return value;\n  },\n\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n\n  transform(value) {\n    return value;\n  }\n\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case 'function':\n        if (process.env.NODE_ENV === 'development') {\n          const r = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r)) result[key] = r;\n        } else {\n          result[key] = resolver.call(result, config[key], key, config);\n        }\n\n        break;\n\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n\n  return result;\n}\nfunction parse(config, gestureKey) {\n  const _ref = config,\n        {\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  } = _ref,\n        rest = _objectWithoutProperties(_ref, _excluded);\n\n  const _config = {\n    shared: resolveWith({\n      target,\n      eventOptions,\n      window,\n      enabled,\n      transform\n    }, sharedConfigResolver)\n  };\n\n  if (gestureKey) {\n    const resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = ConfigResolverMap.get(key);\n\n      if (resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (process.env.NODE_ENV === 'development') {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl) {\n    _defineProperty(this, \"_listeners\", []);\n\n    this._ctrl = ctrl;\n  }\n\n  add(element, device, action, handler, options) {\n    const type = toDomEventType(device, action);\n\n    const eventOptions = _objectSpread2(_objectSpread2({}, this._ctrl.config.shared.eventOptions), options);\n\n    element.addEventListener(type, handler, eventOptions);\n\n    this._listeners.push(() => element.removeEventListener(type, handler, eventOptions));\n  }\n\n  clean() {\n    this._listeners.forEach(remove => remove());\n\n    this._listeners = [];\n  }\n\n}\n\nclass TimeoutStore {\n  constructor() {\n    _defineProperty(this, \"_timeouts\", new Map());\n  }\n\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n\n    if (timeout) window.clearTimeout(timeout);\n  }\n\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n\n    this._timeouts.clear();\n  }\n\n}\n\nclass Controller {\n  constructor(handlers) {\n    _defineProperty(this, \"gestures\", new Set());\n\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n\n    _defineProperty(this, \"gestureEventStores\", {});\n\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n\n    _defineProperty(this, \"handlers\", {});\n\n    _defineProperty(this, \"config\", {});\n\n    _defineProperty(this, \"pointerIds\", new Set());\n\n    _defineProperty(this, \"touchIds\", new Set());\n\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n\n    resolveGestures(this, handlers);\n  }\n\n  setEventIds(event) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event));\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n    }\n  }\n\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey);\n  }\n\n  clean() {\n    this._targetEventStore.clean();\n\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const eventOptions = sharedConfig.eventOptions;\n    const props = {};\n    let target;\n\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n\n    const bindFunction = bindToProps(props, eventOptions, !!target);\n\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        if (this.config[gestureKey].enabled) {\n          const Engine = EngineMap.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n\n      for (const eventKey in this.nativeHandlers) {\n        bindFunction(eventKey, '', event => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp]);\n    }\n\n    if (!target) return props;\n\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = parseProp(handlerProp);\n\n      this._targetEventStore.add(target, device, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n\n}\n\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\n\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\n\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n\n  return [handlers, native, actions];\n}\n\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n\n  if (!EngineMap.has(key)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n\n    return;\n  }\n\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\n\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\nexport { Controller, parseMergedHandlers };\n","import { registerAction, dragAction, pinchAction, wheelAction, scrollAction, moveAction, hoverAction } from '@use-gesture/core/actions';\nexport * from '@use-gesture/core/actions';\nimport React from 'react';\nimport { Controller, parseMergedHandlers } from '@use-gesture/core';\nexport * from '@use-gesture/core/utils';\nexport * from '@use-gesture/core/types';\n\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = React.useMemo(() => new Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  React.useEffect(ctrl.effect.bind(ctrl));\n  React.useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n\n  if (config.target === undefined) {\n    return ctrl.bind.bind(ctrl);\n  }\n\n  return undefined;\n}\n\nfunction useDrag(handler, config = {}) {\n  registerAction(dragAction);\n  return useRecognizers({\n    drag: handler\n  }, config, 'drag');\n}\n\nfunction usePinch(handler, config = {}) {\n  registerAction(pinchAction);\n  return useRecognizers({\n    pinch: handler\n  }, config, 'pinch');\n}\n\nfunction useWheel(handler, config = {}) {\n  registerAction(wheelAction);\n  return useRecognizers({\n    wheel: handler\n  }, config, 'wheel');\n}\n\nfunction useScroll(handler, config = {}) {\n  registerAction(scrollAction);\n  return useRecognizers({\n    scroll: handler\n  }, config, 'scroll');\n}\n\nfunction useMove(handler, config = {}) {\n  registerAction(moveAction);\n  return useRecognizers({\n    move: handler\n  }, config, 'move');\n}\n\nfunction useHover(handler, config = {}) {\n  registerAction(hoverAction);\n  return useRecognizers({\n    hover: handler\n  }, config, 'hover');\n}\n\nfunction createUseGesture(actions) {\n  actions.forEach(registerAction);\n  return function useGesture(_handlers, _config = {}) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = parseMergedHandlers(_handlers, _config);\n    return useRecognizers(handlers, config, undefined, nativeHandlers);\n  };\n}\n\nfunction useGesture(handlers, config = {}) {\n  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);\n  return hook(handlers, config);\n}\n\nexport { createUseGesture, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };\n","import { RefObject, useCallback, useRef, useState } from 'react';\nimport { createUseGesture, dragAction } from '@use-gesture/react';\nimport { ScreenSize, default as useScreenSize } from './use-screen-size';\nimport usePrevious from './use-previous';\n\ninterface CarouselProps {\n  itemCount: number;\n}\n\nexport interface CarouselBehavior<TRef extends HTMLElement> {\n  scrollableRef: RefObject<TRef>;\n  navigate: (direction: number) => void;\n  reset: () => void;\n  hasPrevItem: boolean;\n  hasNextItem: boolean;\n  screenSize: ScreenSize;\n  prevScreenSize?: ScreenSize;\n  currentPosition: number;\n}\n\nexport default function useCarouselBehavior<TRef extends HTMLElement>({\n  itemCount\n}: CarouselProps): CarouselBehavior<TRef> {\n  const scrollableRef: RefObject<TRef> = useRef(null);\n  const screenSize = useScreenSize();\n  const prevScreenSize = usePrevious(screenSize);\n  const [currentPosition, setCurrentPosition] = useState<number>(0);\n\n  const hasPrevItem = currentPosition > 0;\n  const hasNextItem = itemCount > currentPosition + 1;\n\n  const navigate = useCallback(\n    (direction: number) => {\n      if (scrollableRef.current) {\n        const newPosition = currentPosition + direction;\n        const percentage = -newPosition * 100;\n        scrollableRef.current.style.transform = `translateX(${percentage}%)`;\n        setCurrentPosition(newPosition);\n      }\n    },\n    [currentPosition]\n  );\n\n  const reset = useCallback(() => {\n    if (scrollableRef.current) {\n      scrollableRef.current.style.transform = 'translateX(-0%)';\n      setCurrentPosition(0);\n    }\n  }, []);\n\n  const useGesture = createUseGesture([dragAction]);\n  useGesture(\n    {\n      onDragEnd: state => {\n        const {\n          xy: [x1],\n          initial: [x0]\n        } = state;\n        const deltaX = x1 - x0;\n        if (deltaX > 0 && hasPrevItem) {\n          navigate(-1);\n        } else if (deltaX < 0 && hasNextItem) {\n          navigate(1);\n        }\n      }\n    },\n    { target: scrollableRef, eventOptions: { passive: false } }\n  );\n\n  return {\n    scrollableRef,\n    hasPrevItem,\n    hasNextItem,\n    screenSize,\n    prevScreenSize,\n    navigate,\n    reset,\n    currentPosition\n  };\n}\n","import { useEffect } from 'react';\nimport { ScreenSize } from './use-screen-size';\nimport { default as useCarouselBehavior, CarouselBehavior } from './use-carousel-behavior';\n\ninterface MultiCarouselProps {\n  desktopColumnCount: number;\n  itemCount: number;\n}\n\ninterface MultiCarouselBehavior<TRef extends HTMLElement>\n  extends Omit<CarouselBehavior<TRef>, 'currentPosition'> {\n  countPerSlide: number;\n}\n\nexport default function useMultiCarouselBehavior<TRef extends HTMLElement>({\n  desktopColumnCount,\n  itemCount\n}: MultiCarouselProps): MultiCarouselBehavior<TRef> {\n  const { scrollableRef, screenSize, prevScreenSize, navigate, reset, currentPosition } =\n    useCarouselBehavior<TRef>({ itemCount });\n\n  const isSmallScreen = screenSize === ScreenSize.Small;\n  const countPerSlide = isSmallScreen ? 1 : desktopColumnCount;\n  const hasPrevItem = currentPosition > 0;\n  const hasNextItem = itemCount > (currentPosition + 1) * countPerSlide;\n\n  useEffect(() => {\n    const isCurrentSmallScreen = screenSize === ScreenSize.Small;\n    const isPreviousSmallScreen = prevScreenSize === ScreenSize.Small;\n    const changedFromSmallScreen = isPreviousSmallScreen && !isCurrentSmallScreen;\n    const changedToSmallScreen = !isPreviousSmallScreen && isCurrentSmallScreen;\n    if (changedFromSmallScreen || changedToSmallScreen) {\n      reset();\n    }\n  }, [screenSize, prevScreenSize, reset]);\n\n  return {\n    scrollableRef,\n    countPerSlide,\n    hasPrevItem,\n    hasNextItem,\n    screenSize,\n    prevScreenSize,\n    navigate,\n    reset\n  };\n}\n"],"names":["clamp","v","min","max","V","fallback","v1","v2","rubberband","distance","dimension","constant","rubberbandIfOutOfBounds","position","computeRubberband","bounds","Vx","Vy","Rx","Ry","X0","X1","Y0","Y1","_defineProperty","obj","key","value","ownKeys","object","enumerableOnly","keys","symbols","sym","_objectSpread2","target","i","source","EVENT_TYPE_MAP","capitalize","string","toHandlerProp","device","action","capture","deviceProps","actionKey","pointerCaptureEvents","parseProp","prop","eventKey","passive","captureKey","toDomEventType","isTouch","event","getPointerType","getCurrentTargetTouchList","e","_event$currentTarget","_event$currentTarget$","getTouchList","getValueEvent","touchIds","touch","pointerId","valueEvent","pointerValues","getEventDetails","payload","shiftKey","altKey","metaKey","ctrlKey","call","args","noop","chain","fns","result","fn","assignDefault","BEFORE_LAST_KINEMATICS_DELAY","Engine","ctrl","state","shared","ingKey","config","values","dt","_absoluteDelta","_m0","_m1","t0","t1","_step","movement","v0","previousOffset","gestureIsActive","ox","oy","x0","x1","y0","y1","absoluteDelta","memo","selectAxis","dx","dy","threshold","absDx","absDy","CoordinatesEngine","identity","DEFAULT_RUBBERBAND","commonConfigResolver","_k","transform","DEFAULT_AXIS_THRESHOLD","coordinatesConfigResolver","_v","axis","left","right","top","bottom","DISPLACEMENT","KEYS_DELTA_MAP","factor","DragEngine","boundRect","targetRect","_bounds","id","_values","dirx","diry","vx","vy","mx","my","svx","svy","sx","sy","sdt","persistEvent","deltaFn","bindFunction","isBrowser","supportsTouchEvents","isTouchScreen","supportsPointerEvents","supportsPointerLock","supportsGestureEvents","SUPPORT","DEFAULT_PREVENT_SCROLL_DELAY","DEFAULT_DRAG_DELAY","DEFAULT_SWIPE_VELOCITY","DEFAULT_SWIPE_DISTANCE","DEFAULT_SWIPE_DURATION","DEFAULT_DRAG_AXIS_THRESHOLD","dragConfigResolver","lock","mouse","preventScroll","buttons","filterTaps","tapsThreshold","velocity","duration","scaleBounds","angleBounds","_scaleBounds","D","_angleBounds","A","EngineMap","ConfigResolverMap","registerAction","dragAction","_objectWithoutPropertiesLoose","excluded","sourceKeys","_objectWithoutProperties","sourceSymbolKeys","sharedConfigResolver","_excluded","resolveWith","resolvers","resolver","parse","gestureKey","_ref","eventOptions","window","enabled","rest","_config","EventStore","element","handler","options","type","remove","TimeoutStore","callback","ms","timeout","Controller","handlers","resolveGestures","nativeHandlers","sharedConfig","props","bindToProps","handlerProp","setupGesture","internalHandlers","withPassiveOption","isNative","_options$capture","_options$passive","RE_NOT_NATIVE","sortHandlers","_handlers","native","actions","registerGesture","handlerKey","startKey","endKey","parseMergedHandlers","mergedHandlers","mergedConfig","useRecognizers","React","createUseGesture","useCarouselBehavior","itemCount","scrollableRef","useRef","screenSize","useScreenSize","prevScreenSize","usePrevious","currentPosition","setCurrentPosition","useState","hasPrevItem","hasNextItem","navigate","useCallback","direction","newPosition","percentage","reset","deltaX","useMultiCarouselBehavior","desktopColumnCount","countPerSlide","ScreenSize","useEffect","isCurrentSmallScreen","isPreviousSmallScreen"],"mappings":"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"}