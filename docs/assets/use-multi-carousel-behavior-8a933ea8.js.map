{"version":3,"file":"use-multi-carousel-behavior-8a933ea8.js","sources":["../../node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js","../../node_modules/@use-gesture/core/dist/actions-94b581a0.esm.js","../../node_modules/@use-gesture/core/dist/use-gesture-core.esm.js","../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js","../../packages/hooks/src/use-carousel-behavior.ts","../../packages/hooks/src/use-multi-carousel-behavior.ts"],"sourcesContent":["function clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n};\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\nexport { V, computeRubberband as c, rubberbandIfOutOfBounds as r };\n","import { V, c as computeRubberband } from './maths-0ab39ae9.esm.js';\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\nconst actionsWithoutCaptureSupported = ['enter', 'leave'];\nfunction hasCapture(capture = false, actionKey) {\n  return capture && !actionsWithoutCaptureSupported.includes(actionKey);\n}\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? 'Capture' : '');\n}\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event)) return 'touch';\n  if ('pointerType' in event) return event.pointerType;\n  return 'mouse';\n}\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\nfunction distanceAngle(P1, P2) {\n  try {\n    const dx = P2.clientX - P1.clientX;\n    const dy = P2.clientY - P1.clientY;\n    const cx = (P2.clientX + P1.clientX) / 2;\n    const cy = (P2.clientY + P1.clientY) / 2;\n    const distance = Math.hypot(dx, dy);\n    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n    const origin = [cx, cy];\n    return {\n      angle,\n      distance,\n      origin\n    };\n  } catch (_unused) {}\n  return null;\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nconst BEFORE_LAST_KINEMATICS_DELAY = 32;\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = state.timeDelta = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n      state.startTime = state.timeStamp = event.timeStamp;\n    }\n  }\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable) state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n      V.addTo(state._distance, _absoluteDelta);\n    }\n    if (this.axisIntent) this.axisIntent(event);\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n    if (config.hasCustomTransform) {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional) return;\n    const movement = [0, 0];\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = computeRubberband(state._bounds, state.offset, rubberband);\n    state.delta = V.sub(state.offset, previousOffset);\n    this.computeMovement();\n    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n      if (!state.first && dt > 0) {\n        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n        state.timeDelta = dt;\n      }\n    }\n  }\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n}\n\nfunction selectAxis([dx, dy], threshold) {\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n  if (absDx > absDy && absDx > threshold) {\n    return 'x';\n  }\n  if (absDy > absDx && absDy > threshold) {\n    return 'y';\n  }\n  return undefined;\n}\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n  computeOffset() {\n    this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n  }\n  computeMovement() {\n    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n  }\n  axisIntent(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state.axis && event) {\n      const threshold = typeof config.axisThreshold === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n      state.axis = selectAxis(state._movement, threshold);\n    }\n    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n  }\n  restrictToAxis(v) {\n    if (this.config.axis || this.config.lockDirection) {\n      switch (this.state.axis) {\n        case 'x':\n          v[1] = 0;\n          break;\n        case 'y':\n          v[0] = 0;\n          break;\n      }\n    }\n  }\n}\n\nconst identity = v => v;\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n  eventOptions(value, _k, config) {\n    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);\n  },\n  preventDefault(value = false) {\n    return value;\n  },\n  triggerAllEvents(value = false) {\n    return value;\n  },\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n      case false:\n        return [0, 0];\n      default:\n        return V.toVector(value);\n    }\n  },\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return V.toVector(value);\n  },\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n    if (process.env.NODE_ENV === 'development') {\n      const originalTransform = transform || identity;\n      return v => {\n        const r = originalTransform(v);\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);\n        }\n        return r;\n      };\n    }\n    return transform || identity;\n  },\n  threshold(value) {\n    return V.toVector(value, 0);\n  }\n};\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n      return NaN;\n    },\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n      return NaN;\n    },\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\n\nconst DEFAULT_AXIS_THRESHOLD = 0;\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {\n    return value;\n  },\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n    if ('current' in value) {\n      return () => value.current;\n    }\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n});\n\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],\n  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],\n  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],\n  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n  setup() {\n    const state = this.state;\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n    const ctrlIds = this.ctrl.setEventIds(event);\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n    if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n      if (config.triggerAllEvents) {\n        this.compute(event);\n        this.emit();\n      }\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    if (state.type === event.type && event.timeStamp === state.timeStamp) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    const _values = pointerValues(event);\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n    V.addTo(state._movement, state._delta);\n    this.compute(event);\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove('dragDelay');\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n    this.emit();\n  }\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [_dx, _dy] = state._delta;\n      const [_mx, _my] = state._movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n      if (state.elapsedTime < sdt) {\n        const _vx = Math.abs(_dx / state.timeDelta);\n        const _vy = Math.abs(_dy / state.timeDelta);\n        if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);\n        if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);\n      }\n    }\n    this.emit();\n  }\n  pointerClick(event) {\n    if (!this.state.tap && event.detail > 0) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n    if (process.env.NODE_ENV === 'development') {\n      try {\n        if (device === 'pointer' && config.preventScrollDelay === undefined) {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n    }\n  }\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n  setupScrollPrevention(event) {\n    this.state._preventScroll = false;\n    persistEvent(event);\n    const remove = this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', remove);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', remove);\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      this.start(event);\n      state._delta = deltaFn(this.config.keyboardDisplacement, factor);\n      state._keyboardActive = true;\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n    }\n    if (this.config.keys) {\n      bindFunction('key', 'down', this.keyDown.bind(this));\n      bindFunction('key', 'up', this.keyUp.bind(this));\n    }\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n}\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst DEFAULT_KEYBOARD_DISPLACEMENT = 10;\nconst DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1,\n      keys = true\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    this.keys = keys;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = undefined\n  }) {\n    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration\n    };\n  },\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n      case false:\n        return 0;\n      default:\n        return value;\n    }\n  },\n  axisThreshold(value) {\n    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  },\n  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {\n    return value;\n  }\n});\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n      return NaN;\n    },\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n      return NaN;\n    },\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\n\nfunction clampStateInternalMovementToBounds(state) {\n  const [ox, oy] = state.overflow;\n  const [dx, dy] = state._delta;\n  const [dirx, diry] = state._direction;\n  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n    state._movement[0] = state._movementBound[0];\n  }\n  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n    state._movement[1] = state._movementBound[1];\n  }\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 100;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'pinching');\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n    if (type === 'wheel') {\n      this.state.offset = V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n  axisIntent() {\n    const state = this.state;\n    const [_m0, _m1] = state._movement;\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n  }\n  restrictToAxis(v) {\n    if (this.config.lockDirection) {\n      if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    if (!payload) return;\n    this.pinchStart(event, payload);\n  }\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    if (!payload) return;\n    this.pinchStart(event, payload);\n  }\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    if (!payload) return;\n    this.pinchMove(event, payload);\n  }\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    if (!payload) return;\n    this.pinchMove(event, payload);\n  }\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n    if (!state._active) return;\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  wheel(event) {\n    const modifierKey = this.config.modifierKey;\n    if (modifierKey && !event[modifierKey]) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if (process.env.NODE_ENV === 'development' && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n    }\n    if (this.config.pinchOnWheel) {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n  modifierKey(value) {\n    if (value === undefined) return 'ctrlKey';\n    return value;\n  },\n  pinchOnWheel(value = true) {\n    return value;\n  }\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\nexport { ConfigResolverMap as C, EngineMap as E, SUPPORT as S, _objectSpread2 as _, _defineProperty as a, touchIds as b, chain as c, toHandlerProp as d, dragAction as e, pinchAction as f, hoverAction as h, isTouch as i, moveAction as m, parseProp as p, registerAction as r, scrollAction as s, toDomEventType as t, wheelAction as w };\n","import { S as SUPPORT, C as ConfigResolverMap, _ as _objectSpread2, a as _defineProperty, t as toDomEventType, i as isTouch, b as touchIds, E as EngineMap, c as chain, p as parseProp, d as toHandlerProp } from './actions-94b581a0.esm.js';\nimport './maths-0ab39ae9.esm.js';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n    return undefined;\n  },\n  enabled(value = true) {\n    return value;\n  },\n  window(value = SUPPORT.isBrowser ? window : undefined) {\n    return value;\n  },\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n  transform(value) {\n    return value;\n  }\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case 'function':\n        if (process.env.NODE_ENV === 'development') {\n          const r = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r)) result[key] = r;\n        } else {\n          result[key] = resolver.call(result, config[key], key, config);\n        }\n        break;\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n  return result;\n}\nfunction parse(newConfig, gestureKey, _config = {}) {\n  const _ref = newConfig,\n    {\n      target,\n      eventOptions,\n      window,\n      enabled,\n      transform\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  _config.shared = resolveWith({\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  }, sharedConfigResolver);\n  if (gestureKey) {\n    const resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = ConfigResolverMap.get(key);\n      if (resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (process.env.NODE_ENV === 'development') {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl, gestureKey) {\n    _defineProperty(this, \"_listeners\", new Set());\n    this._ctrl = ctrl;\n    this._gestureKey = gestureKey;\n  }\n  add(element, device, action, handler, options) {\n    const listeners = this._listeners;\n    const type = toDomEventType(device, action);\n    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};\n    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);\n    element.addEventListener(type, handler, eventOptions);\n    const remove = () => {\n      element.removeEventListener(type, handler, eventOptions);\n      listeners.delete(remove);\n    };\n    listeners.add(remove);\n    return remove;\n  }\n  clean() {\n    this._listeners.forEach(remove => remove());\n    this._listeners.clear();\n  }\n}\n\nclass TimeoutStore {\n  constructor() {\n    _defineProperty(this, \"_timeouts\", new Map());\n  }\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n    if (timeout) window.clearTimeout(timeout);\n  }\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n    this._timeouts.clear();\n  }\n}\n\nclass Controller {\n  constructor(handlers) {\n    _defineProperty(this, \"gestures\", new Set());\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n    _defineProperty(this, \"gestureEventStores\", {});\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n    _defineProperty(this, \"handlers\", {});\n    _defineProperty(this, \"config\", {});\n    _defineProperty(this, \"pointerIds\", new Set());\n    _defineProperty(this, \"touchIds\", new Set());\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n    resolveGestures(this, handlers);\n  }\n  setEventIds(event) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event));\n      return this.touchIds;\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n      return this.pointerIds;\n    }\n  }\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey, this.config);\n  }\n  clean() {\n    this._targetEventStore.clean();\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const props = {};\n    let target;\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        const gestureConfig = this.config[gestureKey];\n        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);\n        if (gestureConfig.enabled) {\n          const Engine = EngineMap.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);\n      for (const eventKey in this.nativeHandlers) {\n        nativeBindFunction(eventKey, '', event => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp]);\n    }\n    if (!target) return props;\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = parseProp(handlerProp);\n      this._targetEventStore.add(target, device, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n}\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n  return [handlers, native, actions];\n}\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n  if (!EngineMap.has(key)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n    return;\n  }\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\nexport { Controller, parseMergedHandlers };\n","import { registerAction, dragAction, pinchAction, wheelAction, scrollAction, moveAction, hoverAction } from '@use-gesture/core/actions';\nexport * from '@use-gesture/core/actions';\nimport React from 'react';\nimport { Controller, parseMergedHandlers } from '@use-gesture/core';\nexport * from '@use-gesture/core/utils';\nexport * from '@use-gesture/core/types';\n\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = React.useMemo(() => new Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  React.useEffect(ctrl.effect.bind(ctrl));\n  React.useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n  if (config.target === undefined) {\n    return ctrl.bind.bind(ctrl);\n  }\n  return undefined;\n}\n\nfunction useDrag(handler, config) {\n  registerAction(dragAction);\n  return useRecognizers({\n    drag: handler\n  }, config || {}, 'drag');\n}\n\nfunction usePinch(handler, config) {\n  registerAction(pinchAction);\n  return useRecognizers({\n    pinch: handler\n  }, config || {}, 'pinch');\n}\n\nfunction useWheel(handler, config) {\n  registerAction(wheelAction);\n  return useRecognizers({\n    wheel: handler\n  }, config || {}, 'wheel');\n}\n\nfunction useScroll(handler, config) {\n  registerAction(scrollAction);\n  return useRecognizers({\n    scroll: handler\n  }, config || {}, 'scroll');\n}\n\nfunction useMove(handler, config) {\n  registerAction(moveAction);\n  return useRecognizers({\n    move: handler\n  }, config || {}, 'move');\n}\n\nfunction useHover(handler, config) {\n  registerAction(hoverAction);\n  return useRecognizers({\n    hover: handler\n  }, config || {}, 'hover');\n}\n\nfunction createUseGesture(actions) {\n  actions.forEach(registerAction);\n  return function useGesture(_handlers, _config) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = parseMergedHandlers(_handlers, _config || {});\n    return useRecognizers(handlers, config, undefined, nativeHandlers);\n  };\n}\n\nfunction useGesture(handlers, config) {\n  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);\n  return hook(handlers, config || {});\n}\n\nexport { createUseGesture, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };\n","import { RefObject, useCallback, useRef, useState } from 'react';\nimport { createUseGesture, dragAction } from '@use-gesture/react';\nimport { ScreenSize, default as useScreenSize } from './use-screen-size';\nimport usePrevious from './use-previous';\n\ninterface CarouselProps {\n  itemCount: number;\n}\n\nexport interface CarouselBehavior<TRef extends HTMLElement> {\n  scrollableRef: RefObject<TRef>;\n  navigate: (direction: number) => void;\n  reset: () => void;\n  hasPrevItem: boolean;\n  hasNextItem: boolean;\n  screenSize: ScreenSize;\n  prevScreenSize?: ScreenSize;\n  currentPosition: number;\n}\n\nexport default function useCarouselBehavior<TRef extends HTMLElement>({\n  itemCount\n}: CarouselProps): CarouselBehavior<TRef> {\n  const scrollableRef: RefObject<TRef> = useRef(null);\n  const screenSize = useScreenSize();\n  const prevScreenSize = usePrevious(screenSize);\n  const [currentPosition, setCurrentPosition] = useState<number>(0);\n\n  const hasPrevItem = currentPosition > 0;\n  const hasNextItem = itemCount > currentPosition + 1;\n\n  const navigate = useCallback(\n    (direction: number) => {\n      if (scrollableRef.current) {\n        const newPosition = currentPosition + direction;\n        const percentage = -newPosition * 100;\n        scrollableRef.current.style.transform = `translateX(${percentage}%)`;\n        setCurrentPosition(newPosition);\n      }\n    },\n    [currentPosition]\n  );\n\n  const reset = useCallback(() => {\n    if (scrollableRef.current) {\n      scrollableRef.current.style.transform = 'translateX(-0%)';\n      setCurrentPosition(0);\n    }\n  }, []);\n\n  const useGesture = createUseGesture([dragAction]);\n  useGesture(\n    {\n      onDragEnd: state => {\n        const {\n          xy: [x1],\n          initial: [x0]\n        } = state;\n        const deltaX = x1 - x0;\n        if (deltaX > 0 && hasPrevItem) {\n          navigate(-1);\n        } else if (deltaX < 0 && hasNextItem) {\n          navigate(1);\n        }\n      }\n    },\n    { target: scrollableRef, eventOptions: { passive: false } }\n  );\n\n  return {\n    scrollableRef,\n    hasPrevItem,\n    hasNextItem,\n    screenSize,\n    prevScreenSize,\n    navigate,\n    reset,\n    currentPosition\n  };\n}\n","import { useEffect } from 'react';\nimport { ScreenSize } from './use-screen-size';\nimport { default as useCarouselBehavior, CarouselBehavior } from './use-carousel-behavior';\n\ninterface MultiCarouselProps {\n  desktopColumnCount: number;\n  itemCount: number;\n}\n\ninterface MultiCarouselBehavior<TRef extends HTMLElement>\n  extends Omit<CarouselBehavior<TRef>, 'currentPosition'> {\n  countPerSlide: number;\n}\n\nexport default function useMultiCarouselBehavior<TRef extends HTMLElement>({\n  desktopColumnCount,\n  itemCount\n}: MultiCarouselProps): MultiCarouselBehavior<TRef> {\n  const { scrollableRef, screenSize, prevScreenSize, navigate, reset, currentPosition } =\n    useCarouselBehavior<TRef>({ itemCount });\n\n  const isSmallScreen = screenSize === ScreenSize.Small;\n  const countPerSlide = isSmallScreen ? 1 : desktopColumnCount;\n  const hasPrevItem = currentPosition > 0;\n  const hasNextItem = itemCount > (currentPosition + 1) * countPerSlide;\n\n  useEffect(() => {\n    const isCurrentSmallScreen = screenSize === ScreenSize.Small;\n    const isPreviousSmallScreen = prevScreenSize === ScreenSize.Small;\n    const changedFromSmallScreen = isPreviousSmallScreen && !isCurrentSmallScreen;\n    const changedToSmallScreen = !isPreviousSmallScreen && isCurrentSmallScreen;\n    if (changedFromSmallScreen || changedToSmallScreen) {\n      reset();\n    }\n  }, [screenSize, prevScreenSize, reset]);\n\n  return {\n    scrollableRef,\n    countPerSlide,\n    hasPrevItem,\n    hasNextItem,\n    screenSize,\n    prevScreenSize,\n    navigate,\n    reset\n  };\n}\n"],"names":["clamp","v","min","max","V","fallback","v1","v2","rubberband","distance","dimension","constant","rubberbandIfOutOfBounds","position","computeRubberband","bounds","Vx","Vy","Rx","Ry","X0","X1","Y0","Y1","_toPrimitive","input","hint","prim","res","_toPropertyKey","arg","key","_defineProperty","obj","value","ownKeys","object","enumerableOnly","keys","symbols","sym","_objectSpread2","target","i","source","EVENT_TYPE_MAP","capitalize","string","actionsWithoutCaptureSupported","hasCapture","capture","actionKey","toHandlerProp","device","action","deviceProps","pointerCaptureEvents","parseProp","prop","eventKey","passive","captureKey","toDomEventType","isTouch","event","getPointerType","getCurrentTargetTouchList","e","_event$currentTarget","_event$currentTarget$","getTouchList","getValueEvent","touchIds","touch","pointerId","valueEvent","pointerValues","getEventDetails","payload","shiftKey","altKey","metaKey","ctrlKey","call","args","noop","chain","fns","result","fn","assignDefault","BEFORE_LAST_KINEMATICS_DELAY","Engine","ctrl","state","shared","ingKey","config","values","dt","_absoluteDelta","_m0","_m1","t0","t1","_step","movement","v0","previousOffset","gestureIsActive","ox","oy","x0","x1","y0","y1","absoluteDelta","memo","selectAxis","dx","dy","threshold","absDx","absDy","CoordinatesEngine","identity","DEFAULT_RUBBERBAND","commonConfigResolver","_k","transform","DEFAULT_AXIS_THRESHOLD","coordinatesConfigResolver","_v","axis","left","right","top","bottom","KEYS_DELTA_MAP","displacement","factor","DragEngine","boundRect","targetRect","_bounds","ctrlIds","id","_values","_dx","_dy","_mx","_my","svx","svy","sx","sy","sdt","_vx","_vy","persistEvent","remove","deltaFn","bindFunction","isBrowser","supportsTouchEvents","isTouchScreen","supportsPointerEvents","supportsPointerLock","supportsGestureEvents","SUPPORT","DEFAULT_PREVENT_SCROLL_DELAY","DEFAULT_DRAG_DELAY","DEFAULT_SWIPE_VELOCITY","DEFAULT_SWIPE_DISTANCE","DEFAULT_SWIPE_DURATION","DEFAULT_KEYBOARD_DISPLACEMENT","DEFAULT_DRAG_AXIS_THRESHOLD","dragConfigResolver","lock","mouse","preventScroll","buttons","filterTaps","tapsThreshold","velocity","duration","scaleBounds","angleBounds","_scaleBounds","D","_angleBounds","A","EngineMap","ConfigResolverMap","registerAction","dragAction","_objectWithoutPropertiesLoose","excluded","sourceKeys","_objectWithoutProperties","sourceSymbolKeys","sharedConfigResolver","_excluded","resolveWith","resolvers","resolver","parse","newConfig","gestureKey","_config","_ref","eventOptions","window","enabled","rest","EventStore","element","handler","options","listeners","type","_options","TimeoutStore","callback","ms","timeout","Controller","handlers","resolveGestures","nativeHandlers","sharedConfig","props","gestureConfig","bindToProps","nativeBindFunction","handlerProp","setupGesture","internalHandlers","withPassiveOption","isNative","_options$capture","_options$passive","RE_NOT_NATIVE","sortHandlers","_handlers","native","actions","registerGesture","handlerKey","startKey","endKey","parseMergedHandlers","mergedHandlers","mergedConfig","useRecognizers","React","createUseGesture","useCarouselBehavior","itemCount","scrollableRef","useRef","screenSize","useScreenSize","prevScreenSize","usePrevious","currentPosition","setCurrentPosition","useState","hasPrevItem","hasNextItem","navigate","useCallback","direction","newPosition","percentage","reset","deltaX","useMultiCarouselBehavior","desktopColumnCount","countPerSlide","ScreenSize","useEffect","isCurrentSmallScreen","isPreviousSmallScreen"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}