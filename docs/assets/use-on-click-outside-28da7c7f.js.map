{"version":3,"file":"use-on-click-outside-28da7c7f.js","sources":["../../packages/hooks/src/use-window-event-listener.ts","../../packages/hooks/src/use-on-click-outside.ts"],"sourcesContent":["import { useEffect, useRef } from 'react';\n\n/**\n * Reference: https://usehooks.com/useEventListener/\n * Tweaked to run on both server and client sides. Reference to window object\n * takes place only on client side\n *\n * @param eventName     Event name to attach specified event handler to\n * @param handler       Event handler\n */\nexport default function useWindowEventListener<T extends keyof WindowEventMap>(\n  eventName: T,\n  handler: (this: Window, evt: WindowEventMap[T]) => any\n) {\n  // Create a ref that stores handler\n  const savedHandler = useRef(handler);\n  // Update ref.current value if handler changes.\n  // This allows our effect below to always get latest handler ...\n  // ... without us needing to pass it in effect deps array ...\n  // ... and potentially cause effect to re-run every render.\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(\n    () => {\n      // Create event listener that calls handler function stored in ref\n      const eventListener = (event: WindowEventMap[T]) => savedHandler.current.call(window, event);\n      // Add event listener\n      window.addEventListener(eventName, eventListener);\n      // Remove event listener on cleanup\n      return () => {\n        window.removeEventListener(eventName, eventListener);\n      };\n    },\n    [eventName] // Re-run if eventName changes\n  );\n}\n","import { RefObject, useCallback } from 'react';\nimport useWindowEventListener from './use-window-event-listener';\n\ntype CallbackEvent = MouseEvent | PointerEvent;\n\n/**\n * Reference: https://usehooks.com/useOnClickOutside/\n *\n * @param ref       Reference to DOM element to detect if click happens\n *                  outside of the element\n * @param callback  Callback function when click outside is detected\n */\nexport default function useOnClickOutside<TRef extends HTMLElement>(\n  ref: RefObject<TRef>,\n  callback: (event: CallbackEvent) => void\n) {\n  const listener = useCallback(\n    (event: CallbackEvent) => {\n      // Do nothing if clicking ref's element or descendent elements\n      if (!ref.current || ref.current.contains(event.target as Node)) {\n        return;\n      }\n      callback(event);\n    },\n    // Add ref and callback to effect dependencies\n    // It's worth noting that because passed in callback is a new ...\n    // ... function on every render that will cause this effect ...\n    // ... callback/cleanup to run every render. It's not a big deal ...\n    // ... but to optimize you can wrap callback in useCallback before ...\n    // ... passing it into this hook.\n    [ref, callback]\n  );\n  useWindowEventListener('pointerdown', listener);\n  useWindowEventListener('mousedown', listener);\n}\n"],"names":["useWindowEventListener","eventName","handler","savedHandler","useRef","useEffect","eventListener","event","useOnClickOutside","ref","callback","listener","useCallback"],"mappings":"wCAUwB,SAAAA,EACtBC,EACAC,EACA,CAEM,MAAAC,EAAeC,SAAOF,CAAO,EAKnCG,EAAAA,UAAU,IAAM,CACdF,EAAa,QAAUD,CAAA,EACtB,CAACA,CAAO,CAAC,EAEZG,EAAA,UACE,IAAM,CAEJ,MAAMC,EAAiBC,GAA6BJ,EAAa,QAAQ,KAAK,OAAQI,CAAK,EAEpF,cAAA,iBAAiBN,EAAWK,CAAa,EAEzC,IAAM,CACJ,OAAA,oBAAoBL,EAAWK,CAAa,CAAA,CAEvD,EACA,CAACL,CAAS,CAAA,CAEd,CCzBwB,SAAAO,EACtBC,EACAC,EACA,CACA,MAAMC,EAAWC,EAAA,YACdL,GAAyB,CAEpB,CAACE,EAAI,SAAWA,EAAI,QAAQ,SAASF,EAAM,MAAc,GAG7DG,EAASH,CAAK,CAChB,EAOA,CAACE,EAAKC,CAAQ,CAAA,EAEhBV,EAAuB,cAAeW,CAAQ,EAC9CX,EAAuB,YAAaW,CAAQ,CAC9C"}